# SPDX-FileCopyrightText: 2023 Richard Masters <grick23@gmail.com>
# SPDX-License-Identifier: MIT
#
# Builder-Hex0 is a small bootable machine image which has
# the ability to compile hex0 code. It is also written in hex0
# and so it can build itself if provided with its own source code.
#
# hex0 is a "language" for binary encoding in hexadecimal
# with support for comments.

# 16 bit Functions
# ----------------
# kernel_entry
# console_putc_16
# console_put_hex_16
#
# read_sectors_16
# write_sectors_16
#
# [GDT data]
# kernel_main

# 32 bit Functions
# ----------------
# setup_int_handlers
# stub_interrupt_handler
# enter_16bit_real
# resume_32bit_mode
#
# console_putc
# console_put_hex
# console_puts
# read_sectors
# write_sectors
#
# syscall_interrupt_handler
# handle_syscall_open
# handle_syscall_close
# absolute_path
# find_file
# fd_to_file_index
# handle_syscall_read
# handle_syscall_brk
# handle_syscall_write
# handle_syscall_fork
# handle_syscall_execve
# handle_syscall_chdir
# handle_syscall_exit
# handle_syscall_waitpid
# handle_syscall_lseek
# handle_syscall_access
# handle_syscall_mkdir
# handle_syscall_getcwd
#
# strcmp
#
# read
# write
# src
# hex0
# flush_disk
# internalshell


#------------------------------------------------------------
# Memory:
# 54000000 - BFFFFFFF files (~1812MB)
# 30000000 - 53FFFFFF saved processes (~604MB)
# 08048000 - 2FFFFFFF current running process (~670MB)
# 01080000 - 08000000 32 bit stack (117MB)
# 01000010 - 0107FFFF file descriptors (16 bytes each * 32K)
#                      { unused, address, length, unused }
# 01000000 - 0100000F stdin disk locator
#                      { logical sector (4 bytes), offset (2 bytes), unused }
#   201800 -   FFFFFF file names 6..14335
#   201400 -   2017FF file name 5
#   201000 -   2013FF file name 4
#   100000 -   200FF0 unused
#    9FC00 -    FFFFF BIOS
#    40200 -    9FBFF scratch buffer
#    40000 -    401FF stdin device buffer
#    20000 -    3FFFF process descriptors ( 16 * 4096 bytes each)
#                      offset len    description
#                      0x000  0x004  process address
#                      0x004  0x004  brk pointer
#                      0x008  0x004  saved stack pointer (first process only)
#                      0x00C  0x004  saved stack pointer
#                      0x010  0x004  forked?
#                      0x014  0x004  saved brk pointer
#                      0x018  0x004  child exit code
#                      0x01C  0x004  address of saved process memory
#                      0x020  0x004  length of process memory
#                      0x024  0x004  address of saved process stack
#                      0x028  0x004  length of saved process stack
#                      0x02C  0x01C  unused
#                      0x100  0x100  current directory
#                      0x200  x0E00  file descriptors 448 * 8 bytes each
#                                    { global_file_index, current_offset }
#    10800 -    1FFFF unused
#    10000 -    107FF interrupt table
#     A000 -     A1FF sector read buffer - 16bit
#     7C00 -     8600 code
#     7B00 -     7BFF Saved 32 bit registers while in 16 bit mode
#   < 7B00            real mode stack
#------------------------------------------------------------


#------------------------------------------------------------
:kernel_entry
# inputs:
#   dl: boot drive
#
# We cannot be sure the registers are initialized to zero so we
# do that first. We far jump in order to set CS.
# Use special encoding of "xor ax, ax" to appease some BIOSes.
33 C0              # xor ax, ax
EA $setcs 00 00    # jmp far setcs
:setcs
8E D8              # mov ds, ax
8E C0              # mov es, ax
8E D0              # mov ss, ax
BC 00 7B           # mov sp, 0x7B00
FC                 # cld ; clear direction flag

E9 @kernel_main    # jmp kernel_main


#------------------------
:console_putc_16
# input:
#   al: char to print
#
# Note: with QEMU+Seabios this does not flush the last character or
# CRLF of a line until the first character is output on the next line
# and that character cannot be another CRLF.
53              # push bx
50              # push ax

# Prepare to use BIOS tty output interrupt.
# Specify text page 00, 0 black background, 7 light grey text
BB 00 07        # mov bx, 0x0007
# Specify the `write character` BIOS routine
B4 0E           # mov ah, 0x0E

3C 0A           # cmp al, 0x0A
75 !regular     # jne regular

# convert LF to CR LF for BIOS output
B0 0D           # mov al, 0x0D
CD 10           # int 0x10
B0 0A           # mov al, 0x0A

:regular
CD 10           # int 0x10

58              # pop ax
5B              # pop bx
C3              # ret


#------------------------
:console_put_hex_16
# input:
#   al: byte to print as hex
#
50                   # push ax

24 F0                # and al, 0xF0
C0 E8 04             # shr al, 4
3C 09                # cmp al, 9
7F !alpha1           # jg alpha1

# numeral
04 30                # add al, 0x30
EB !print1           # jmp print1

:alpha1
04 37                # add al, 0x37

:print1
E8 @console_putc_16  # call console_putc_16

58                   # pop ax        ; restore original al
50                   # push ax       ;

24 0F                # and al, 0x0F
3C 09                # cmp al, 9
7F !alpha2           # jg alpha2

# numeral
04 30                # add al, 0x30
EB !print2           # jmp print2

:alpha2
04 37                # add al, 0x37

:print2
E8 @console_putc_16  # call console_putc_16

58                   # pop ax
C3                   # ret



#-------------
:boot_drive
80

# align address packet to 16 byte boundary
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

#-------------
:addr_packet
10 00
:num_sectors_bios
01 00
:dest_offset
00 00
:dest_segment
00 00
:starting_lba
00 00 00 00 00 00 00 00
:end_addr_packet

#------------------------
:read_sectors_16
# inputs:
#   di: dest_addr
#   ecx: first logical sector
#   ax: num_sectors
#
# outputs:
#   di: next byte to write to
#   ecx: next disk sector to read from
#
50                       # push ax
53                       # push bx
56                       # push si

1E                       # push ds
5B                       # pop bx
89 1E $dest_segment      # mov word ptr [dest_segment], bx
89 C6                    # mov si, ax      ; si=num_sectors
89 FB                    # mov bx, di      ; int 13 writes to bx

:read_one_loop
89 36 $num_sectors_bios  # mov word ptr [num_sectors_bios], si
89 1E $dest_offset       # mov word ptr [dest_offset], bx
66 89 0E $starting_lba   # mov dword ptr [starting_lba], ecx
8A 16 $boot_drive        # mov dl, [boot_drive]
B4 42                    # mov ah, 0x42        ; rw mode = 42 (read LBA)
56                       # push si
BE $addr_packet          # mov si, addr_packet      ; disk address packet
CD 13                    # int 0x13
72 !read_error           # jc read_error

8B 3E $num_sectors_bios  # mov di, word ptr [num_sectors_bios]  ; number of sectors actually read
85 FF                    # test di, di
74 !read_error           # jz read_error

# we read some sectors, advance
5E                       # pop si
29 FE                    # sub si, di    ; num_sectors -= num_sectors_bios
66 0F B7 C7              # movzx eax, di
66 01 C1                 # add ecx, eax
C1 E7 09                 # shl di, 9     ; 512 == 2^9
01 FB                    # add bx, di

85 F6                    # test si, si
75 !read_one_loop        # jnz read_one_loop

89 DF                    # mov di, bx

5E                       # pop si
5B                       # pop bx
58                       # pop ax
C3                       # retf

:read_error
# Print the error code, followed by the disk address packet
8A 16 $boot_drive        # mov dl, [boot_drive]
88 E0                    # mov al, ah
9A &console_put_hex_16   # call console_put_hex_16
B0 20                    # mov al, 0x20
9A &console_putc_16      # call console_putc_16
BE $addr_packet          # mov si, addr_packet      ; disk address packet
:read_debug
8A 04                    # mov al, [si]
9A &console_put_hex_16   # call console_put_hex_16
46                       # inc si
81 FE $end_addr_packet   # cmp si, end_addr_packet
75 !read_debug           # jnz read_debug

# Reset the disk subsystem, then try again
8A 16 $boot_drive        # mov dl, [boot_drive]
31 C0                    # xor ax, ax
CD 13                    # int 0x13
5E                       # pop si
EB !read_one_loop        # jmp read_one_loop


#------------------------
:write_sectors_16
# inputs:
#   si: source_addr
#   ecx: first logical sector
#   ax: num_sectors
#
# outputs:
#   si: next byte to read from
#   ecx: next disk sector to write to
#
50                      # push ax
53                      # push bx
57                      # push di

1E                      # push ds
5B                      # pop bx
89 1E $dest_segment     # mov word ptr [dest_segment], bx
89 C7                   # mov di, ax      ; di=num_sectors
89 F3                   # mov bx, si      ; int 13 reads from [bx]

:write_one_loop
89 3E $num_sectors_bios # mov word ptr [num_sectors_bios], di
89 1E $dest_offset      # mov word ptr [dest_offset], bx
66 89 0E $starting_lba  # mov dword ptr [starting_lba], ecx
8A 16 $boot_drive       # mov dl, [boot_drive]
B4 43                   # mov ah, 0x43       ; rw mode = 43 (write LBA)
BE $addr_packet         # mov si, addr_packet      ; disk address packet

CD 13                   # int 0x13
72 !write_error         # jc write_error

8B 36 $num_sectors_bios # mov si, word ptr [num_sectors_bios]  ; number of sectors actually written
85 F6                   # test si, si
74 !write_error         # jz write_error

# we wrote some sectors, advance
29 F7                   # sub di, si    ; num_sectors -= num_sectors_bios
66 0F B7 C6             # movzx eax, si
66 01 C1                # add ecx, eax
C1 E6 09                # shl si, 9     ; 512 == 2^9
01 F3                   # add bx, si

85 FF                   # test di, di
75 !write_one_loop      # jnz write_one_loop

89 DE                   # mov si, bx

5F                      # pop di
5B                      # pop bx
58                      # pop ax
C3                      # retf

:write_error
# Print the error code, followed by the disk address packet
8A 16 $boot_drive       # mov dl, [boot_drive]
88 E0                   # mov al, ah
9A &console_put_hex_16  # call console_put_hex_16
B0 20                   # mov al, 0x20
9A &console_putc_16     # call console_putc_16
BF $addr_packet         # mov di, addr_packet      ; disk address packet
:write_debug
8A 05                   # mov al, [di]
9A &console_put_hex_16  # call console_put_hex_16
47                      # inc di
81 FF $end_addr_packet  # cmp di, end_addr_packet
75 !write_debug         # jnz write_debug

# Reset the disk subsystem, then try again
8A 16 $boot_drive       # mov dl, [boot_drive]
31 C0                   # xor ax, ax
CD 13                   # int 0x13
EB !write_one_loop      # jmp write_one_loop


# align GDT to 16 byte boundary
00 00 00 00 00

#---------------------------------------------
# The Global Descriptor Table for 32 bit mode.
#---------------------------------------------
:GDT_start
00 00 00 00 00 00 00 00

:GDT_code32
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
CF    # 11001111b
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    #

:GDT_data32
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
CF    # flags, limit 16:19 11001111b
      #   granularity=1 32-bit-default=1 64-bit seg=0 AVL=0
00    # base 24:31

:GDT_code16
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
9A    # access byte 10011010b
      #   present=1 privilege=00 type=1
      #   code=1 conforming=0 readable=1 accessed=0
8F    # 10001111b
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    #

:GDT_data16
FF FF # limit 0:15
00 00 # base  0:15
00    # base 16:23
92    # access byte 10010010b
      #   present=1 privilege=00 type=1
      #   code=0 conforming=0 readable=1 accessed=0
8F    # flags, limit 16:19 10001111b
      #   granularity=1 32-bit-default=0 64-bit seg=0 AVL=0
00    # base 24:31

#------
:GDT_locator
27 00        #  length
&GDT_start   #  GDT_start

#------
:Saved_GDT_locator
00 00        #  length
00 00 00 00  #  GDT_start


#------------------------
:kernel_main
# inputs:
#   dl: boot_drive
#
# Load the kernel and jump to it
88 16 $boot_drive       # mov [boot_drive], dl

# if this is not stage1 skip load; kernel is already loaded
B8 $kernel_entry        # mov ax, $kernel_entry
3D 00 7C                # cmp ax, 0x7C00
75 !after_load          # jne after_load

BF 00 7E                # mov di, 0x7E00   ; place remaining code after MBR in memory
B8 07 00                # mov ax, 7        ; num_sectors = 7
66 B9 01 00 00 00       # mov ecx, 1       ; starting logical sector = 1
E8 @read_sectors_16     # call read_sectors_16

:after_load
# check if A20 line needs handling
9C                      # pushf
1E                      # push ds
06                      # push es
FA                      # cli

31 C0                   # xor ax, ax ; ax = 0
8E C0                   # mov es, ax

F7 D0                   # not ax ; ax = 0xFFFF
8E D8                   # mov ds, ax

BF 00 05                # mov di, 0x0500
BE 10 05                # mov si, 0x0510

26 8A 05                # mov al, byte ptr es:[di]
50                      # push ax

8A 04                   # mov al, byte ptr ds:[si]
50                      # push ax

26 C6 05 00             # mov byte ptr es:[di], 0x00
C6 04 FF                # mov byte ptr ds:[si], 0xFF

26 80 3D FF             # cmp byte ptr es:[di], 0xFF

58                      # pop ax
88 04                   # mov byte ptr ds:[si], al

58                      # pop ax
26 88 05                # mov byte ptr es:[di], al

B8 00 00                # mov ax, 0
74 !check_a20_exit      # je check_a20_exit

B8 01 00                # mov ax, 1

:check_a20_exit
FB                      # sti
07                      # pop es
1F                      # pop ds
9D                      # popf

A3 $Init_A20            # mov word ptr [Init_A20], ax
85 C0                   # test ax, ax
75 !init_no_a20         # jnz init_no_a20

# enable Gate A20
B8 01 24                # mov ax,2401h     # enable A20 line
CD 15                   # int 15h

:init_no_a20
# start 32bit mode
FA                      # cli
0F 01 06 $Saved_GDT_locator # sgdt Saved_GDT_locator
EB !past_MBR            # jmp past_MBR
90                      # nop    ; padding to align MBR
90                      # nop    ; padding to align MBR
90                      # nop    ; padding to align MBR
90                      # nop    ; padding to align MBR
# This is the DOS/MBR identifier at offset 510:
55 AA
:past_MBR
0F 01 16 $GDT_locator   # lgdt GDT_locator
0F 20 C0                # mov eax, cr0
66 83 C8 01             # or eax, 0x01
0F 22 C0                # mov cr0, eax
EA $setup_32bit 08 00   # jmp setup_32bit     ; sets CS

#------
:setup_32bit
66 B8 10 00             # mov ax, 0x0010      ; data descriptor
8E D8                   # mov ds, ax
8E D0                   # mov ss, ax
8E C0                   # mov es, ax
8E E0                   # mov fs, ax
8E E8                   # mov gs, ax
BD 00 00 00 08          # mov ebp, 0x08000000
89 EC                   # mov esp, ebp

E8 %setup_int_handlers  # call setup_int_handlers
E9 %internalshell       # jmp internalshell


#----------------------------------------
:setup_int_handlers
53                        # push ebx

# handle the timer interrupt 08
BB 40 00 01 00            # mov ebx, &interrupt_table[08]
66 C7 03 $stub_interrupt_handler     # mov word [ebx + 0], low_address stub_interrupt_handler
66 C7 43 06 00 00         # mov word [ebx + 6], high_address
66 C7 43 02 08 00         # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E               # mov byte [ebx + 5], flags = 8E

# handle int 80
BB 00 04 01 00            # mov ebx, &interrupt_table[80]
66 C7 03 $syscall_interrupt_handler  # mov word [ebx + 0], low_address syscall_interrupt_handler
66 C7 43 06 00 00         # mov word [ebx + 6], high_address
66 C7 43 02 08 00         # mov word [ebx + 2], code_segment = 0x0800
C6 43 05 8E               # mov byte [ebx + 5], flags = 8E

# load the interrupt table
FA                        # cli
0F 01 1D &IDT_locator_32  # lidt IDT_locator_32
8B 1D &have_userspace     # mov ebx, [have_userspace]
85 DB                     # test ebx
74 !before_userspace      # jz before_userspace
FB                        # sti
:before_userspace
5B                        # pop ebx
C3                        # ret


#----------------------------------------
:stub_interrupt_handler
CF                    # iret

#----------------------------------------
:Init_A20
00 00

#----------------------------------------
:have_userspace
00 00 00 00

# align IDT locator to 16 byte boundary
00 00 00 00 00 00 00 00 00 00 00 00

#----------------------------------------
:IDT_locator_32
FF 07        #  length
00 00 01 00  #  IDT_start


#------------------------------------------------------------
# 32 -> 16 -> 32 bit switching functions
#------------------------------------------------------------
# When switching between real mode and
# protected, registers are stored here:
#
# 7B14  edx
# 7B10
# 7B0C
# 7B08  eax
# 7B04  esp
#
# 7B00  <- top of real mode stack

#----------------------------------------
:enter_16bit_real
FA                        # cli
A3 08 7B 00 00            # mov [0x7B08], eax  ; preserve so we can use these locally
89 15 14 7B 00 00         # mov [0x7B14], edx  ;
5A                        # pop edx            ; capture return address
89 25 04 7B 00 00         # mov [0x7B04], esp  ; capture stack

# The following far jump sets CS to a 16-bit protected mode selector
# and the segment registers are also set to 16-bit protected mode selectors.
# This is done prior to entering real mode.
EA &setup_16bit 18 00 # jmp 0x18:setup_16bit
#------
:setup_16bit
B8 20 00                  # mov ax, 0x0020
8E D0                     # mov ss, ax
8E D8                     # mov ds, ax
8E C0                     # mov es, ax
8E E8                     # mov gs, ax
8E E0                     # mov fs, ax
BC 00 7B                  # mov sp, 0x7B00
0F 20 C0                  # mov eax, cr0
66 83 E0 FE               # and eax, 0xfffffffe  ; clear protected mode
0F 22 C0                  # mov cr0, eax
# The following far jump sets CS to a 16-bit real mode segment
# and the segment registers are also set to real mode segments.
EA &real_mode             # jmp 0000:XXXX  real_mode
#------
:real_mode
B8 00 00                  # mov ax, 0x0
8E D8                     # mov ds, ax
8E E0                     # mov fs, ax
8E E8                     # mov gs, ax
8E D0                     # mov ss, ax
8E C0                     # mov es, ax
BC 00 7B                  # mov sp, 0x7B00
FA                        # cli
0F 01 1E $IDT_locator_16  # lidt IDT_locator_16
0F 01 16 $Saved_GDT_locator # lgdt Saved_GDT_locator
FB                        # sti

# Reset Gate A20 if needed
A1 $Init_A20              # mov ax, word ptr [Init_A20]
85 C0                     # test ax, ax
75 !enter_no_a20          # jnz enter_no_a20
B8 00 24                  # mov ax,2400h     # disable A20 line
CD 15                     # int 15h

:enter_no_a20
# Using retf to set CS comes from here:
# https://stackoverflow.com/questions/26448480/bios-interrupts-in-protected-mode
# This page recommends a far jump followed by sti:
# https://www.sudleyplace.com/pmtorm.html
6A 00                     # push 0x0000 (2 bytes!)  CS to return to
52                        # push dx  IP to return to
A1 08 7B                  # mov ax, [0x7B08]  ; restore from above
8B 16 14 7B               # mov dx, [0x7B14]
CB                        # retf

# align IDT locator to 16-byte boundary
00 00 00 00 00 00 00 00 00 00 00 00 00 00

#------
:IDT_locator_16
FF 03
00 00 00 00


#----------------------------------------
:resume_32bit_mode
50                           # push ax
A1 $Init_A20                 # mov ax, word ptr [Init_A20]
85 C0                        # test ax, ax
75 !exit_no_a20              # jnz exit_no_a20

# start 32bit mode
B8 01 24                     # mov ax,2401h     # enable A20 line
CD 15                        # int 15h

:exit_no_a20
58                           # pop ax
FA                           # cli
A3 08 7B                     # mov [0x7B08], ax  ; preserve, they might be return values from 16 bit
89 16 14 7B                  # mov [0x7B14], dx
5A                           # pop dx      ; carry the return IP in dx
58                           # pop ax      ; CS
0F 01 06 $Saved_GDT_locator  # sgdt Saved_GDT_locator
0F 01 16 $GDT_locator        # lgdt GDT_locator
0F 20 C0                     # mov eax, cr0
66 83 C8 01                  # or eax, 0x01         ; enable protected mode
0F 22 C0                     # mov cr0, eax
EA $restore_32bit 08 00      # jmp restore_32bit
#------
:restore_32bit
B8 10 00 00 00               # mov eax, 0x0010      ; data descriptor
8E D8                        # mov ds, eax
8E D0                        # mov ss, eax
8E C0                        # mov es, eax
8E E0                        # mov fs, eax
8E E8                        # mov gs, eax
8B 25 04 7B 00 00            # mov esp, [0x7B04]   ; restore, (saved in enter_16bit_mode)
E8 %setup_int_handlers       # call setup_int_handlers
52                           # push edx            ; setup our return location
# These restore the 16 bit portion of these registers, which may be a
# return value from a 16 bit function, and they also restore any previous high
# bits that were stored by enter_16bit_mode so these registers need not be
# saved when going to 16 bit mode and back if you want them left alone.
A1 08 7B 00 00               # mov eax, [0x7B08]   ; restore, (saved at top of this function)
8B 15 14 7B 00 00            # mov edx, [0x7B14]
C3                           # ret


#------------------------
:console_putc
#
E8 %enter_16bit_real    # call enter_16bit_real
E8 @console_putc_16     # call console_putc_16(al)
9A &resume_32bit_mode   # call resume_32bit_mode
C3                      # ret


#------------------------
:console_put_hex
E8 %enter_16bit_real    # call enter_16bit_real
E8 @console_put_hex_16  # call console_put_hex_16(al)
9A &resume_32bit_mode   # call resume_32bit_mode
C3                      # ret


#------------------------
:console_puts
# inputs
#   ds:si: string to print
50                      # push eax
56                      # push esi
:puts_loop
8A 06                   # mov al, [esi]
3C 00                   # cmp al, 0
74 !end_puts_loop       # jz end_puts_loop
E8 %console_putc        # call console_putc
46                      # inc esi
EB !puts_loop           # jmp puts_loop
:end_puts_loop
B0 0A                   # mov al, 0A
E8 %console_putc        # call console_putc
5E                      # pop esi
58                      # pop eax
C3                      # ret


#------------------------
:read_sectors
# inputs:
#   di: dest_addr
#   ecx: first logical sector
#   ax: num_sectors
#
E8 %enter_16bit_real    # call enter_16bit_real
E8 @read_sectors_16     # call read_sectors_16
9A &resume_32bit_mode   # call resume_32bit_mode
C3                      # ret


#------------------------
:write_sectors
# inputs:
#   si: source_addr
#   ecx: first logical sector
#   ax: num_sectors
#
E8 %enter_16bit_real    # call enter_16bit_real
E8 @write_sectors_16    # call write_sectors_16
9A &resume_32bit_mode   # call resume_32bit_mode
C3                      # ret

#------------------------
:reboot
E8 %enter_16bit_real    # call enter_16bit_real
FA                      # cli
EA F0 FF 00 F0          # ljmp $F000:FFF0          ; reboot


#------------------------
:syscall_interrupt_handler
#
3C 01                             # cmp al, 1
75 !check_fork                    # jne check_fork
E8 %handle_syscall_exit           # call handle_syscall_exit
CF                                # iret

:check_fork
3C 02                             # cmp al, 2
75 !check_read                    # jne check_read
E8 %handle_syscall_fork           # call handle_syscall_fork
CF                                # iret

:check_read
3C 03                             # cmp al, 3
75 !check_write                   # jne check_write
E8 %handle_syscall_read           # call handle_syscall_read
CF                                # iret

:check_write
3C 04                             # cmp al, 4
75 !check_open                    # jne check_open
E8 %handle_syscall_write          # call handle_syscall_write
CF                                # iret

:check_open
3C 05                             # cmp al, 5
75 !check_close                   # jne check_close
E8 %handle_syscall_open           # call handle_syscall_open
CF                                # iret

:check_close
3C 06                             # cmp al, 6
75 !check_waitpid                 # jne check_waitpid
E8 %handle_syscall_close          # call handle_syscall_close
CF                                # iret

:check_waitpid
3C 07                             # cmp eax, 7
75 !check_execve                  # jne check_execve
E8 %handle_syscall_waitpid        # call handle_syscall_waitpid
CF                                # iret

:check_execve
3C 0B                             # cmp eax, B
75 !check_chdir                   # jne check_chdir
E8 %handle_syscall_execve         # call handle_syscall_execve
CF                                # iret

:check_chdir
3C 0C                             # cmp al, C
75 !check_lseek                   # jne check_lseek
E8 %handle_syscall_chdir          # call handle_syscall_chdir
CF                                # iret

:check_lseek
3C 13                             # cmp al, 0x13
75 !check_brk                     # jne check_brk
E8 %handle_syscall_lseek          # call handle_syscall_lseek
CF                                # iret

:check_brk
3C 2D                             # cmp al, 2D
75 !check_access                  # jne check_access
E8 %handle_syscall_brk            # call handle_syscall_brk
CF                                # iret

:check_access
3C 21                             # cmp al, 0x21
75 !check_mkdir                   # jne check_mkdir
E8 %handle_syscall_access         # call handle_syscall_access
CF                                # iret

:check_mkdir
3C 27                             # cmp al, 0x27
75 !check_wait4                   # jne check_wait4
E8 %handle_syscall_mkdir          # call handle_syscall_mkdir
CF                                # iret

:check_wait4
3C 72                             # cmp eax, 0x72
75 !check_getcwd                  # jne check_getcwd
31 C0                             # xor eax, eax
89 01                             # mov [ecx], eax
CF                                # iret

:check_getcwd
3C B7                             # cmp al, 0xB7
75 !syscall_ok                    # jne syscall_ok
E8 %handle_syscall_getcwd         # call handle_syscall_getcwd
CF                                # iret

:syscall_ok
# return success for all unimplemented syscalls
31 C0                             # xor eax, eax
CF                                # iret


#------
:next_filenum
04 00 00 00

#------
:next_file_address
00 00 00 54

#----------------------------------------
:handle_syscall_open
# inputs:
#   ebx: filename
#   ecx: flags
#
53                          # push ebx
51                          # push ecx
56                          # push esi
57                          # push edi

E8 %absolute_path           # call absolute_path

F7 C1 40 00 00 00           # test ecx, 0x40         ; 0x40 is O_CREAT
74 !open_read               # jz open_read

# Create new file

# Exit with error if directory does not exist

# Go the end of filename
89 DE                       # mov esi, ebx
:end_loop
AC                          # lodsb
3C 00                       # cmp al, 0
75 !end_loop                # jne end_loop
# Look in reverse for last slash
4E                          # dec esi
FD                          # std                     ; go backwards
:find_slash_loop
AC                          # lodsb
3C 2F                       # cmp al, '/'
75 !find_slash_loop         # jne find_slash_loop
# If first slash at start, its root, so it exists
FC                          # cld
46                          # inc esi
39 DE                       # cmp esi, ebx
74 !after_dir_lookup        # je after_dir_lookup
# Zero out slash
31 C0                       # xor eax, eax
89 F7                       # mov edi, esi
AA                          # stosb
# Lookup directory
E8 %find_file               # call find_file           ; eax=find_file(ebx)
# Restore first char
C6 47 FF 2F                 # mov byte [edi - 1], 0x2f
83 F8 FF                    # cmp eax, -1
75 !after_dir_lookup        # jne after_dir_lookup
E9 %open_finish_fail        # jmp open_finish_fail

:after_dir_lookup

# copy filename to new slot
89 DE                       # mov esi, ebx
BF 00 00 20 00              # mov edi, 0x0200000
A1 &next_filenum            # mov eax, [next_filenum]
C1 E0 0A                    # shl eax, 0a
01 C7                       # add edi, eax
B9 00 04 00 00              # mov ecx, 0x0000400
F3 A4                       # rep movsb

# set address of file
BF 00 00 00 01              # mov edi, 0x01000000           ; pfile_descriptor = &file_descriptor[0]
A1 &next_filenum            # mov eax, [next_filenum]
C1 E0 04                    # shl eax, 04
01 C7                       # add edi, eax                  ; pfile_descriptor += sizeof(file_descriptor) * next_filenum
8B 0D &next_file_address    # mov ecx, [next_file_address]

89 4F 04                    # mov [edi+4], ecx              ; pfile_descriptor->file_addr = ecx

31 C0                       # xor eax, eax
89 47 08                    # mov [edi+8], eax              ; pfile_descriptor->length = 0

A1 &next_filenum            # mov eax, [next_filenum]       ; return next_filenum
FF 05 &next_filenum         # inc [next_filenum]
EB !syscall_open_finish     # jmp syscall_open_finish

:open_read
E8 %find_file               # call find_file
83 F8 FF                    # cmp eax, -1
74 !open_finish_fail        # je open_finish_fail

89 C1                       # mov ecx, eax
# set read offset to start of file
BE 00 00 00 01              # mov esi, 0x01000000      ; pfile_descriptor = &file_descriptor[0]
C1 E1 04                    # shl ecx, 04
01 CE                       # add esi, ecx             ; pfile_descriptor += sizeof(file_descriptor) * filenum

:syscall_open_finish
8B 35 &next_process_num     # mov esi, [next_process_num]
4E                          # dec esi = current process
C1 E6 0C                    # shl esi, 0x0C
81 C6 20 02 02 00           # add esi, 0x0020220       ; pproc_descriptor = &pproc_descriptor[current_process_num].open_files[4]

6A 04                       # push 0x04                ; start at fd=4
59                          # pop ecx
:find_slot_loop
8B 1E                       # mov ebx, [esi]           ; get file number of fd slot
85 DB                       # test ebx, ebx            ; is this fd slot available?
74 !got_slot                # jz got_slot
41                          # inc ecx                  ; no, go to next slot
83 C6 08                    # add esi, 0x08
EB !find_slot_loop          # jmp find_slot_loop
:got_slot
89 06                       # mov [esi], eax           ; store file number in slot
89 C8                       # mov eax, ecx             ; return fd

31 C9                       # xor ecx, ecx             ; set current file offset to zero
89 4E 04                    # mov [esi+0x4], ecx

#--------
:open_finish_fail

5F                          # pop edi
5E                          # pop esi
59                          # pop ecx
5B                          # pop ebx
C3                          # ret


#----------------------------------------
:handle_syscall_close
# inputs:
#   ebx: fd

57                          # push edi
8B 3D &next_process_num     # mov edi, [next_process_num]
4F                          # dec edi = current process
C1 E7 0C                    # shl edi, 0x0C
81 C7 00 02 02 00           # add edi, 0x00020200       ; edi = all_procs[current_process_num].open_files
31 C0                       # xor eax, eax
89 04 DF                    # mov [edi+ebx*8], eax      ; open_files[fd].global_index = 0
5F                          # pop edi
C3                          # ret


#----------------------------------------
:absolute_path
# inputs:
#   ebx: path
# outputs:
#   ebx: absolute path
#
50                            # push eax
52                            # push edx
56                            # push esi
57                            # push edi

BF 00 02 04 00                # mov edi, 0x00040200      ; scratch buffer
57                            # push edi

# if absolute path, skip prefixing current directory
80 3B 2F                      # cmp [ebx], '/'
74 !strcpy_path_arg           # je strcpy_path_arg

# get cwd
8B 35 &next_process_num       # mov esi, [next_process_num]
4E                            # dec esi = current process
C1 E6 0C                      # shl esi, 0x0C
81 C6 00 01 02 00             # add esi, 0x0020100       ; pproc_descriptor = &pproc_descriptor[current_process_num].current_dir

:strcpy_cwd_loop
AC                            # lodsb
84 C0                         # test al, al
74 !strcpy_path_arg           # jz strcpy_path_arg
AA                            # stosb
EB !strcpy_cwd_loop           # jmp strcpy_cwd_loop

:strcpy_path_arg
89 DE                         # mov esi, ebx
# skip leading ./
66 81 3E 2E 2F                # cmp word [esi], 0x2F2E
75 !strcpy_path               # jne strcpy_path
46                            # inc esi
46                            # inc esi

:strcpy_path
31 DB                         # xor ebx, ebx            ; init last_char
:strcpy_path_loop
AC                            # lodsb
3C 2F                         # cmp al, '/'
75 !ok_path_char              # jne ok_path_char
80 FB 2F                      # cmp bl, '/'
74 !skip_extra_slash          # je skip_extra_slash
:ok_path_char
AA                            # stosb
:skip_extra_slash
84 C0                         # test al, al
74 !maybe_strip_ending_slash  # jz maybe_strip_ending_slash
88 C3                         # mov bl, al              ; save last_char
EB !strcpy_path_loop          # jmp strcpy_path_loop

:maybe_strip_ending_slash
80 FB 2F                      # cmp bl, '/'
75 !handle_dots               # jne handle_dots
31 C0                         # xor eax, eax
4F                            # dec edi
4F                            # dec edi
AA                            # stosb

# handle /. and /..
:handle_dots
5A                            # pop edx                  ; record first parent
52                            # push edx

:handle_dots_loop
5E                            # pop esi                  ; get start location
56                            # push esi                 ; save start location

:find_slash
AC                            # lodsb
3C 00                         # cmp al, 0
74 !absolute_path_finish      # je absolute_path_finish
3C 2F                         # cmp al, '/'
75 !find_slash                # jne find_slash

:found_slash
AC                            # lodsb
# check for /. or /..
3C 00                         # cmp al, 0
74 !absolute_path_finish      # je absolute_path_finish
3C 2E                         # cmp al, '.'
74 !dot_or_dotdot             # je dot_or_dotdot
89 F2                         # mov edx, esi             ; record start of parent
4A                            # dec edx                  ; go back to slash
4A                            # dec edx
EB !find_slash                # jmp find_slash
:dot_or_dotdot
AC                            # lodsb
3C 2E                         # cmp al, '.'
75 !remove_slashdot           # jne remove_slashdot

:remove_parent
89 D7                         # mov edi, edx
:copy
AC                            # lodsb
AA                            # stosb
3C 00                         # cmp al, 0
75 !copy                      # jne copy
EB !handle_dots_loop          # jmp handle_dots_loop

:remove_slashdot
3C 00                         # cmp al, 0
75 !not_ending_slashdot       # jne not_ending_slashdot
4E                            # dec esi                    ; go back to null
:not_ending_slashdot
89 F7                         # mov edi, esi
4F                            # dec edi
4F                            # dec edi
:copy_over_slashdot
AC                            # lodsb
AA                            # stosb
3C 00                         # cmp al, 0
75 !copy_over_slashdot        # jne copy_over_slashdot
EB !handle_dots_loop          # jmp handle_dots_loop

:absolute_path_finish
5B                            # pop ebx

# restore / if necessary
80 3B 00                      # cmp byte [ebx], 0
75 !abs_path_done             # jne abs_path_done
66 C7 03 2F 00                # mov word [ebx], 0x002F

:abs_path_done
5F                            # pop edi
5E                            # pop esi
5A                            # pop edx
58                            # pop eax
C3                            # ret


#----------------------------------------
:find_file
# inputs:
#   ebx: file_name
# outputs:
#   eax: filenum
#
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi

A1 &next_filenum      # mov eax, [next_filenum]
48                    # dec eax
89 DE                 # mov esi, ebx

:checkfile
83 F8 03              # cmp eax, 3
74 !not_found         # je not_found
89 C7                 # mov edi, eax
C1 E7 0A              # shl edi, 0x0a
81 C7 00 00 20 00     # add edi, 0x0200000
E8 %strcmp            # call strcmp
74 !find_file_finish  # je find_file_finish
48                    # dec eax
EB !checkfile         # jmp checkfile

:not_found
B8 FF FF FF FF        # mov eax, 0xffffffff

:find_file_finish
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
C3                    # ret


#------------------------------------------------------------
:fd_to_file_index
# inputs:
#   ebx: file descriptor number
# outputs:
#   ebx: global file index
57                       # push edi
8B 3D &next_process_num  # mov edi, [next_process_num]
4F                       # dec edi = current process
C1 E7 0C                 # shl edi, 0x0C
81 C7 00 02 02 00        # add edi, 0x00020200       ; edi = all_procs[current_process_num].open_files
8B 1C DF                 # mov ebx, [edi+ebx*8]
5F                       # pop edi
C3                       # ret


#------------------------------------------------------------
:handle_syscall_read
# inputs:
#   ecx: *return_char
#   ebx: file
#   edx: length
#
85 D2                   # test edx, edx
75 !nonzero_read        # jnz nonzero_read
31 C0                   # xor eax, eax
C3                      # ret

:nonzero_read
53                      # push ebx
51                      # push ecx
52                      # push edx
56                      # push esi
57                      # push edi

51                      # push ecx   ; we need this later to return char
83 FB 00                # cmp ebx, 0
75 !read_memfile        # jne read_memfile

# stdin disk position is stored in fd 0
# get current position
BB 00 00 00 01          # mov ebx, 0x01000000
8B 0B                   # mov ecx, [ebx]
31 C0                   # xor eax, eax
66 8B 43 04             # mov ax, [ebx+4]

#end of sector?
66 3D FF 01             # cmp ax, 0x01ff
74 !read_next_sector    # je read_next_sector

:nextchar
66 40                   # inc ax
EB !getchar             # jmp getchar

:read_next_sector
BF 00 A0 00 00          # mov edi, 0x000A000
B8 01 00 00 00          # mov eax, 0x0001   ; num_sectors = 1
E8 %read_sectors        # call read_sectors
# save new location and offset
89 0B                   # mov [ebx], ecx
31 C0                   # xor eax, eax

# move block to device buffer
BE 00 A0 00 00           # mov esi, 0x000A000
BF 00 00 04 00           # mov edi, 0x0040000
B9 00 02 00 00           # mov ecx, 0x0000200
F3 A4                    # rep movsb

:getchar
66 A3 04 00 00 01        # mov [0x01000004], ax
59                       # pop ecx
BB 00 00 04 00           # mov ebx, 0x40000    ; device buffer
89 C6                    # mov esi, eax        ; offset
8A 04 33                 # mov al, [ebx+esi+0]
88 01                    # mov [ecx], al
B8 01 00 00 00           # mov eax, 1
EB !syscall_read_finish  # jmp syscall_read_finish

:read_memfile
89 D8                    # mov eax, ebx           ; eax = fd
E8 %fd_to_file_index     # call fd_to_file_index   ; ebx = global file index
# get pointer to global file
BE 00 00 00 01           # mov esi, 0x01000000    ; pfile_descriptor = &file_descriptor[0]
C1 E3 04                 # shl ebx, 04
01 DE                    # add esi, ebx           ; pfile_descriptor += sizeof(file_descriptor) * filenum

# prepare to read
5F                       # pop edi                 ; edi = p_dst
8B 5E 04                 # mov ebx, [esi+4]        ; ebx = pfile_descriptor->file_address
89 D9                    # mov ecx, ebx            ;
03 4E 08                 # add ecx, [esi+0x08]     ; ecx = file_address + length
49                       # dec ecx                 ; ecx = last address to read

8B 35 &next_process_num  # mov esi, [next_process_num]
4E                       # dec esi = current process
C1 E6 0C                 # shl esi, 0x0C
81 C6 04 02 02 00        # add esi, 0x0020204
C1 E0 03                 # shl eax, 3
01 C6                    # add esi, eax            ; esi = &all_procs[current_proc_num].files[eax].current_offset

03 1E                    # add ebx, [esi]          ; ebx = file_addr + current_offset
87 F3                    # xchg esi, ebx           ; esi = p_src, ebx = &pproc_descriptor->offset
31 C0                    # xor eax, eax            ; bytes_read = 0

:syscall_read_loop
39 CE                    # cmp esi, ecx            ; past the end?
77 !syscall_read_finish  # ja syscall_read_finish

A4                       # movsb
40                       # inc eax                 ; bytes_read++
FF 03                    # inc long [ebx]          ; (*pcurrent_offset)++
4A                       # dec edx                 ; length_to_read--
75 !syscall_read_loop    # jnz syscall_read_loop

:syscall_read_finish
5F                       # pop edi
5E                       # pop esi
5A                       # pop edx
59                       # pop ecx
5B                       # pop ebx
C3                       # ret



#------------------------------------------------------------
:handle_syscall_brk
56                    # push esi

A1 &next_process_num  # mov eax, [next_process_num]
48                    # dec eax = current process

BE 00 00 02 00        # mov esi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
C1 E0 0C              # shl eax, 0x0C
01 C6                 # add esi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum

85 DB                 # test ebx, ebx            ; if ebx == 0, just return the current brk
74 !get_brk           # jz get_brk

# set
# initialize memory to zero
57                    # push edi
8B 7E 04              # mov edi, [esi+4]
31 C0                 # xor eax, eax
:init_loop
39 DF                 # cmp edi, ebx
74 !init_done         # je init_done
AA                    # stosb
EB !init_loop         # jmp init_loop
:init_done
5F                    # pop edi

89 5E 04              # mov [esi+4], ebx
89 D8                 # mov eax, ebx
5E                    # pop esi
C3                    # ret

:get_brk
8B 46 04              # mov eax, [esi+4]         ; pproc_descriptor->brk
5E                    # pop esi
C3                    # ret


#------------------------------------------------------------
:handle_syscall_write
# inputs:
#   ebx: file
#   ecx: address of char to write
#   edx: num bytes to write
51                        # push ecx
52                        # push edx
56                        # push esi
57                        # push edi

31 C0                     # xor eax, eax            ; bytes_written = 0

83 FB 02                  # cmp ebx, 02             ; std file?
7F !write_memfile         # jg write_memfile

# stdout,stderr -> console_out
:std_loop
85 D2                     # test edx, edx
74 !syscall_write_finish  # jz syscall_write_finish
50                        # push eax                ; save num_written
8A 01                     # mov al, [ecx]
E8 %console_putc          # call console_putc
58                        # pop eax                 ; restore num_written

40                        # inc eax                 ; num_written++
41                        # inc ecx                 ; p_dst++
4A                        # dec edx                 ; count--
EB !std_loop              # jmp std_loop

:write_memfile
89 CE                     # mov esi, ecx

# use ecx as pointer to fd current offset
8B 0D &next_process_num   # mov ecx, [next_process_num]
49                        # dec ecx = current process
C1 E1 0C                  # shl ecx, 0x0C
81 C1 04 02 02 00         # add ecx, 0x0020204
53                        # push ebx
C1 E3 03                  # shl ebx, 3
01 D9                     # add ecx, ebx            ; ecx = &all_procs[current_proc_num].files[ebx].current_offset
5B                        # pop ebx

# lookup global file index from file descriptor
E8 %fd_to_file_index      # call fd_to_file_index
C1 E3 04                  # shl ebx, 04
81 C3 00 00 00 01         # add ebx, 0x01000000     ; pfile_descriptor += sizeof(file_descriptor) * filenum

8B 7B 04                  # mov edi, [ebx+4]        ; edi = pfile_descriptor->file_address
03 39                     # add edi, [ecx]          ; edi = file_addr + current_offset
:write_loop
85 D2                     # test edx, edx
74 !syscall_write_finish  # jz syscall_write_finish
A4                        # movsb
FF 01                     # inc long [ecx]       ; current_offset++
# If current offset is past previous file length, then increase length
50                        # push eax
8B 01                     # mov eax, [ecx]
3B 43 08                  # cmp eax, [ebx+0x8]
7E !skip_lengthen         # jle skip_lengthen
FF 43 08                  # inc long [ebx+0x8]   ; file_length++
FF 05 &next_file_address  # inc long [next_file_address]
:skip_lengthen
58                        # pop eax
40                        # inc eax              ; num_written++
4A                        # dec edx
EB !write_loop            # jmp write_loop

:syscall_write_finish
5F                        # pop edi
5E                        # pop esi
5A                        # pop edx
59                        # pop ecx
C3                        # ret


#------
:next_save_process_address
00 00 00 30

#----------------------------------------
:handle_syscall_fork
53                    # push ebx
51                    # push ecx
52                    # push edx
56                    # push esi
57                    # push edi
55                    # push ebp

A1 &next_process_num  # mov eax, [next_process_num]
48                    # dec eax = current process
89 C2                 # mov edx, eax
BF 00 00 02 00        # mov edi, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
C1 E0 0C              # shl eax, 0x0C
01 C7                 # add edi, eax             ; pproc_descriptor += sizeof(proc_descriptor) * procnum

8B 77 04              # mov esi, [edi+0x4]       ; save brk pointer
89 77 14              # mov [edi+0x14], esi
89 E6                 # mov esi, esp
89 77 0C              # mov [edi+0xC], esi       ; save stack pointer so we can return again later
FF 47 10              # inc [edi+0x10]           ; fork = true

A1 &next_save_process_address  # mov eax, [next_save_process_address]    ; set save stack location
89 47 24              # mov [edi+0x24], eax

B9 00 00 00 08        # mov ecx, 0x08000000
29 F1                 # sub ecx, esi             ; compute save stack length
01 0D &next_save_process_address  # add [next_save_process_address], ecx
89 4F 28              # mov [edi+0x28], ecx
89 C7                 # mov edi, eax
F3 A4                 # rep movsb                ; save stack

# copy current process image to storage
89 D0                 # mov eax, edx             ; restore current process num
C1 E0 0C              # shl eax, 0x0C
05 00 00 02 00        # add eax, 0x0020000
8B 30                 # mov esi, [eax]           ; esi = pproc_descriptor->process_address

8B 48 14              # mov ecx, [eax+0x14]     ; process_length = brk - process_address
29 F1                 # sub ecx, esi
89 78 1C              # mov [eax+0x1C], edi     ; save address of saved process memory
89 48 20              # mov [eax+0x20], ecx     ; save length of process memory
01 0D &next_save_process_address  # add [next_save_process_address], ecx
F3 A4                 # rep movsb                ; copy current process image to storage

31 C0                 # xor eax, eax             ; return as child, we'll return again as parent when child exits
5D                    # pop ebp
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
C3                    # ret


#------
:next_process_num
01 00 00 00

#----------------------------------------
:handle_syscall_execve
# inputs:
#   ebx: program_name
#   ecx: char **args
#   edx: env
#

A1 &next_process_num  # mov eax, [next_process_num]
3C 01                 # cmp al, 1
75 !not_first_process # jne not_first_process

# first process
BD 00 10 02 00        # mov ebp, 0x00021000      ; ebp = &proc_descriptor[1]
89 65 08              # mov [ebp+0x8], esp       ; save original stack pointer before pushing args
EB !prepare_stack     # jmp prepare_stack

:not_first_process
# check if current process forked or not.
# if so, create new process, if not overlay current
48                    # dec eax                  ; eax = current_process
C1 E0 0C              # shl eax, 0x0C
05 00 00 02 00        # add eax, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
8B 68 10              # mov ebp, [eax+0x10]      ; create_new_process = pproc->forked
85 ED                 # test ebp, ebp            ; did current process fork?
75 !forked            # jnz forked

#not_forked
A1 &next_process_num  # mov eax, [next_process_num]
48                    # dec eax
EB !prepare_stack     # jmp prepare_stack

:forked
FF 48 10              # dec [eax+0x10]           ; fork handled so reset: fork = false
A1 &next_process_num  # mov eax, [next_process_num]


:prepare_stack
# eax=process number to use
# --- env ---
8B 3D &next_save_process_address  # mov edi, [next_save_process_address]
6A 00                 # push 0                   ; push end of env
:push_env_loop
# copy env arg to memory for this process
8B 32                 # mov esi, [edx]
85 F6                 # test esi, esi
74 !end_env_loop      # jz end_env_loop
57                    # push edi                 ; push p_arg
51                    # push ecx
B9 00 01 00 00        # mov ecx, 0x00000100      ; memory per arg
F3 A4                 # rep movsb                ; copy to new memory
59                    # pop ecx
83 C2 04              # add edx, 4
EB !push_env_loop     # jmp push_env_loop


:end_env_loop
# --- args ---
6A 00                 # push 0                   ; push end of args
# count args
31 C0                 # xor eax, eax             ; passed_args = 0
:countloop
83 39 00              # cmp long [ecx], 0
74 !push_args         # jz push_args
40                    # inc eax
83 C1 04              # add ecx, 4
EB !countloop         # jmp countloop

:push_args
89 C2                 # mov edx, eax             ; save eax (can't push)
:push_args_loop
83 E9 04              # sub ecx, 4

# copy arg to memory for this process
8B 31                 # mov esi, [ecx]

57                    # push edi                 ; push p_arg

51                    # push ecx
B9 00 01 00 00        # mov ecx, 0x00000100      ; memory per arg
F3 A4                 # rep movsb
59                    # pop ecx
48                    # dec eax
75 !push_args_loop    # jnz push_args_loop

# finish with argc
89 D0                 # mov eax, edx             ; restore eax
50                    # push eax = argc

# get current process descriptor
A1 &next_process_num  # mov eax, [next_process_num]
48                    # dec eax
50                    # push eax                 ; save current process num
C1 E0 0C              # shl eax, 0x0C
05 00 00 02 00        # add eax, 0x0020000       ; pproc_descriptor = &proc_descriptor[current_process_num]

89 3D &next_save_process_address  # mov [next_save_process_address], edi

# copy cwd from current process
05 00 01 00 00        # add eax, 0x100
89 C6                 # mov esi, eax
05 00 10 00 00        # add eax, 0x1000
89 C7                 # mov edi, eax
:copy_cwd_loop
AC                    # lodsb
AA                    # stosb
3C 00                 # cmp al, 0
75 !copy_cwd_loop     # jne copy_cwd_loop

58                    # pop eax                  ; restore current process num
40                    # inc eax                  ; eax = new process id

# prepare process image in memory
50                    # push eax                 ; save new process id
# get file address and length
E8 %absolute_path     # call absolute_path
E8 %find_file         # call find_file           ; eax=find_file(ebx)

# zero process memory.
# Do this after looking up file name because that may come from process memory.
50                    # push eax
57                    # push edi
31 C0                 # xor eax, eax
BF 00 80 04 08        # mov edi, 0x08048000
B9 00 80 FB 26        # mov ecx, 0x26FB8000
F3 AA                 # rep stosb
5F                    # pop edi
58                    # pop eax

C1 E0 04              # shl eax, 04              ; pfile_descriptor = sizeof(file_descriptor) * filenum
05 00 00 00 01        # add eax, 0x01000000      ; pfile_descriptor += &file_descriptors[0]

8B 40 04              # mov eax, [eax + 0x4]     ; eax = pfile_descriptor->file_address
89 C3                 # mov ebx, eax             ; save file address
31 C9                 # xor ecx, ecx
66 8B 48 2C           # mov cx, [eax + 0x2C]    ; get number of program headers
8B 50 18              # mov edx, [eax + 0x18]    ; get process entry address
03 40 1C              # add eax, [eax + 0x1C]    ; calc first program header address

:program_header_loop
51                    # push ecx                 ; save program header count
8B 70 04              # mov esi, [eax + 4]       ; get segment file source offset
01 DE                 # add esi, ebx             ; calc segment file address
8B 78 08              # mov edi, [eax + 8]       ; get segment memory destination address
8B 48 10              # mov ecx, [eax + 0x10]    ; get segment length
F3 A4                 # rep movsb

83 C0 20              # add eax, 0x20            ; go to next program header
59                    # pop ecx                  ; restore program header count
49                    # dec ecx
75 !program_header_loop  # jnz program_header_loop

58                    # pop eax                  ; restore new process num

85 ED                 # test ebp, ebp            ; new process (vs overlay)?
75 !record_process_address  # jnz record_process_address
48                    # dec eax                  ; overlay

:record_process_address
C1 E0 0C              # shl eax, 0x0C
05 00 00 02 00        # add eax, 0x0020000       ; pproc_descriptor = &pproc_descriptor[current_process_num]

03 5B 1C              # add ebx, [ebx + 0x1C]    ; calc first program header address
8B 5B 08              # mov ebx, [ebx + 0x8]     ; get first segment memory address
89 18                 # mov [eax], ebx           ; pproc_descriptor->process_address = first segment address

# setup brk
81 C7 00 00 02 00     # add edi, 0x00020000      ; brk after last segment plus 0x20000
89 78 04              # mov [eax + 4], edi       ; pproc_descriptor->brk
31 FF                 # xor edi, edi
89 78 10              # mov [eax + 0x10], edi    ; pproc->forked = false

# clear open file descriptors
89 C7                 # mov edi, eax
81 C7 00 02 00 00     # add edi, 0x0000200
31 C0                 # xor eax, eax
B9 00 0E 00 00        # mov ecx, 0x00000E00
F3 AA                 # rep stosb

85 ED                 # test ebp, ebp            ; new process (vs overlay)?
74 !after_new_process # jz after_new_process

# prepare for next process
FF 05 &next_process_num     # inc [next_process_num]

:after_new_process
# get entry point and jump
52                    # push edx
31 C0                 # xor eax, eax
31 DB                 # xor ebx, ebx
31 C9                 # xor ecx, ecx
31 D2                 # xor edx, edx
31 F6                 # xor esi, esi
31 FF                 # xor edi, edi
31 ED                 # xor ebp, ebp
C3                    # ret


#----------------------------------------
:handle_syscall_chdir
56                    # push esi
57                    # push edi

E8 %absolute_path     # call absolute_path
E8 %find_file         # call find_file
83 F8 FF              # cmp eax, -1
74 !chdir_finish      # je chdir_finish

C1 E0 04              # shl eax, 04
05 08 00 00 01        # add eax, 0x01000008     ; eax = &file_descriptor[filenum].file_length
83 38 00              # cmp long [eax], 0
74 !chdir_ok          # je chdir_ok

# can't chdir to a file
B8 FF FF FF FF        # mov eax, -1
EB !chdir_finish      # jmp chdir_finish

:chdir_ok
89 DE                 # mov esi, ebx
8B 3D &next_process_num     # mov edi, [next_process_num]
4F                    # dec edi = current process
C1 E7 0C              # shl edi, 0x0C
81 C7 00 01 02 00     # add edi, 0x0020100       ; pproc_descriptor = &pproc_descriptor[current_process_num].current_dir

AC                    # lodsb    ; first slash
AA                    # stosb
AC                    # lodsb
AA                    # stosb
3C 00                 # cmp al, 0
75 !chdir_loop        # jne chdir_loop
31 C0                 # xor eax, eax
74 !chdir_finish      # je chdir_finish   ; if "/" don't add slash

:chdir_loop
AC                    # lodsb
AA                    # stosb
3C 00                 # cmp al, 0
75 !chdir_loop        # jne chdir_loop
4F                    # dec edi

:add_slash
B0 2F                 # mov al, '/'
AA                    # stosb
31 C0                 # xor eax, eax
AA                    # stosb

:chdir_finish
5F                    # pop edi
5E                    # pop esi
C3                    # ret


#----------------------------------------
:handle_syscall_exit
A1 &next_process_num  # mov eax, [next_process_num]
48                    # dec eax = current process
A3 &next_process_num  # mov [next_process_num], eax
48                    # dec eax = parent process

3C 00                 # cmp al, 0
75 !not_first         # jne not_first
#first process
8B 25 08 10 02 00     # mov esp, [0x021008]
C3                    # ret

:not_first
C1 E0 0C              # shl eax, 0x0C
05 00 00 02 00        # add eax, 0x0020000       ; pproc_descriptor = &proc_descriptor[0]
89 58 18              # mov [eax+0x18], ebx      ; save child exit code

8B 38                 # mov edi, [eax]           ; edi = pproc_descriptor->process_address
8B 70 1C              # mov esi, [eax+0x1C]      ; esi = pproc_descriptor->address_of_saved_process_memory
8B 48 20              # mov ecx, [eax+0x20]      ; ecx = pproc_descriptor->length_of_process_memory
F3 A4                 # rep movsb

8B 70 24              # mov esi, [eax+0x24]                 ; deallocate memory for saved process
89 35 &next_save_process_address  # mov [next_save_process_address], esi

8B 60 0C              # mov esp, [eax+0xc]       ; restore stack pointer
8B 70 14              # mov esi, [eax+0x14]      ; restore brk pointer
89 70 04              # mov [eax+0x4], esi

8B 70 24              # mov esi, [eax+0x24]      ; restore stack
89 E7                 # mov edi, esp
8B 48 28              # mov ecx, [eax+0x28]
F3 A4                 # rep movsb

# mimic syscall_fork's finish
B8 01 00 00 00        # mov eax, 0x1           ; process number for fork
5D                    # pop ebp
5F                    # pop edi
5E                    # pop esi
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
C3                    # ret                    ; go back to parent


#----------------------------------------
:handle_syscall_waitpid
8B 35 &next_process_num  # mov esi, [next_process_num]
4E                       # dec esi = current process
C1 E6 0C                 # shl esi, 0x0C
81 C6 18 00 02 00        # add esi, 0x00020018      ; pchild_code = &pproc_descriptor[current_process_num].child_exit_code
8B 06                    # mov eax, [esi]           ; get exit code
C1 E0 08                 # shl eax, 0x08            ;
89 01                    # mov [ecx], eax           ; waitval = ret << 8
31 C0                    # xor eax, eax
C3                       # ret


#----------------------------------------
:handle_syscall_lseek
# inputs:
#     ebx: fd
#     ecx: value
#     edx: method (0=SEEK_SET, 1=SEEK_CUR, 2=SEEK_END)
# outputs:
#     eax: offset
#
56                    # push esi

8B 35 &next_process_num     # mov esi, [next_process_num]
4E                    # dec esi = current process
C1 E6 0C              # shl esi, 0x0C
81 C6 04 02 02 00     # add esi, 0x0020204       ; pproc_descriptor = &pproc_descriptor[current_process_num].files[0].offset

83 FA 01              # cmp edx, 1
7F !seek_end          # jg seek_end
7C !seek_set          # jl seek_set

:seek_cur
8B 04 DE              # mov eax, [esi+ebx*8]      ; get current_offset
01 C8                 # add eax, ecx              ; current_pos += offset
89 04 DE              # mov [esi+ebx*8], eax      ; set current_pos
5E                    # pop esi
C3                    # ret

:seek_set
89 0C DE              # mov [esi+ebx*8], ecx      ; set current_pos
89 C8                 # mov eax, ecx
5E                    # pop esi
C3                    # ret

:seek_end
56                    # push esi
53                    # push ebx
E8 %fd_to_file_index  # call fd_to_file_index
BE 00 00 00 01        # mov esi, 0x01000000      ; pfile_descriptor = &file_descriptor[0]
C1 E3 04              # shl ebx, 04
01 DE                 # add esi, ebx
8B 46 08              # mov eax, [esi+0x8]        ; get current_length
01 C8                 # add eax, ecx              ; current_length += offset
5B                    # pop ebx
5E                    # pop esi

89 04 DE              # mov [esi+ebx*8], eax      ; set current_offset

5E                    # pop esi
C3                    # ret


#----------------------------------------
:handle_syscall_access
#inputs:
#  ebx: path
#  ecx: mode
E8 %absolute_path        # call absolute_path
E8 %find_file            # call find_file
83 F8 FF                 # cmp eax, -1
74 !access_error_exit    # je access_error_exit
31 C0                    # xor eax, eax
:access_error_exit
C3                       # ret


#----------------------------------------
:handle_syscall_mkdir
#inputs:
#  ebx: path
#  ecx: mode
51                             # push ecx
B9 41 00 00 00                 # mov ecx, 0x41  (O_CREAT | O_WRONLY)
E8 %handle_syscall_open        # call handle_syscall_open
83 F8 FF                       # cmp eax, -1
74 !open_error_exit            # je open_error_exit
31 C0                          # xor eax, eax
:open_error_exit
59                             # pop ecx
C3                             # ret


#----------------------------------------
:handle_syscall_getcwd
#inputs:
#  ebx: buf
#  ecx: buf size
#outputs:
#  eax: buf
56                       # push esi
57                       # push edi

89 DF                    # mov edi, ebx
8B 35 &next_process_num  # mov esi, [next_process_num]
4E                       # dec esi = current process
C1 E6 0C                 # shl esi, 0x0C
81 C6 00 01 02 00        # add esi, 0x0020100       ; pproc_descriptor = &pproc_descriptor[current_process_num].current_dir

# Handle root differently because we don't strip trailing slash
66 83 3E 2F              # cmp word [esi], $002f   ; is cwd == "/" ?
75 !copy_cwd             # jne copy_cwd
66 A5                    # movsw                   ; copy "/" to buffer
EB !getcwd_cleanup       # jmp getcwd_cleanup

:copy_cwd
AC                       # lodsb
AA                       # stosb
3C 00                    # cmp al, 0
75 !copy_cwd             # jne copy_cwd
83 EF 02                 # sub edi, 2              ; strip trailing slash
AA                       # stosb

:getcwd_cleanup
89 D8                    # mov eax, ebx
5F                       # pop edi
5E                       # pop esi
C3                       # ret


#------------------------------------------------------------
:strcmp
# inputs:
#   esi: string1
#   edi: string2
# outputs:
#   zero flag
#
50                    # push eax
53                    # push ebx
56                    # push esi
57                    # push edi

:check_byte
8A 06                 # mov al, [esi]
8A 1F                 # mov bl, [edi]
38 D8                 # cmp al, bl
75 !strcmp_finish     # jne strcmp_finish
46                    # inc esi
47                    # inc edi
84 C0                 # test al, al
75 !check_byte        # jnz check_byte
84 DB                 # test bl, bl
75 !check_byte        # jnz check_byte

:strcmp_finish
5F                    # pop edi
5E                    # pop esi
5B                    # pop ebx
58                    # pop eax
C3                    # ret


#------
:io_char
00
00  # free

#----------------------------------------
:read
53                    # push ebx
51                    # push ecx
52                    # push edx
B8 03 00 00 00        # mov eax, 3   ; syscall=read
B9 &io_char           # mov ecx, io_char
BA 01 00 00 00        # mov edx, 1

CD 80                 # int 80 syscall

3C 00                 # cmp al, 0
74 !read_finish       # je read_finish

B4 01                 # mov ah, 1
A0 &io_char           # mov al, io_char

:read_finish
5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
C3                    # ret


#----------------------------------------
:write
50                    # push eax
53                    # push ebx
51                    # push ecx
52                    # push edx

A2 &io_char           # mov io_char, al
B8 04 00 00 00        # mov eax, 4   ; syscall=write
B9 &io_char           # mov ecx, io_char
BA 01 00 00 00        # mov edx, 1   1 byte characters
CD 80                 # int 80 syscall

5A                    # pop edx
59                    # pop ecx
5B                    # pop ebx
58                    # pop eax
C3                    # ret


#------
:string_src
#s  r  c \0
73 72 63 00

#----------------------------------------
# src: create file from stdin
#
# Read an integer, N, in decimal from stdin.
# Read a space.
# Then, read a file name to create.
# Read a newline.
# Then, read N bytes from stdin and write to the new file.
#----------------------------------------
:src
50                      # push eax
53                      # push ebx
51                      # push ecx
52                      # push edx
56                      # push esi
57                      # push edi

BE &string_src          # mov esi, string_src
E8 %console_puts        # call console_puts

E8 %read                # call read 'r'
E8 %read                # call read 'c'
E8 %read                # call read ' '

31 C9                   # xor ecx, ecx        ; count=0
:parse_count_loop
E8 %read                # call read
3C 20                   # cmp al, ' '
74 !got_count           # je got_count

6B C9 0A                # imul ecx, ecx, 10   ; count = count * 10
2C 30                   # sub al, 30
0F B6 C0                # movzx eax, al
01 C1                   # add ecx, eax        ; count += digit

EB !parse_count_loop    # jmp parse_count_loop

:got_count
# clear arguments
51                      # push ecx
31 C0                   # xor eax, eax
BA 00 00 D0 04          # mov edx, 0x04D00000
B9 00 08 00 00          # mov ecx, 0x00000800

:src_args_zeroloop
88 02                   # mov [edx], al
42                      # inc edx
49                      # dec ecx
75 !src_args_zeroloop   # jnz src_args_zeroloop
59                      # pop ecx

51                      # push ecx
B9 00 00 D0 04          # mov ecx, 0x04D00000
:get_filename_loop
E8 %read                # call read

3C 0A                   # cmp al, '\n'
74 !got_filename        # je got_filename
88 01                   # mov [ecx], al
41                      # inc ecx
EB !get_filename_loop   # jmp get_file_name_loop
:got_filename
59                      # pop ecx

BE 00 00 D0 04          # mov esi, 0x04D00000
E8 %console_puts        # call console_puts

# open filename for write
51                      # push ecx
BB 00 00 D0 04          # mov ebx, 0x04D00000
B8 05 00 00 00          # mov eax, 5  ; syscall_open
B9 41 02 00 00          # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00          # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                   # int 80
59                      # pop ecx
89 C2                   # mov edx, eax

# edx has the open file number

:read_write_loop
85 C9                   # test ecx, ecx
74 !src_finish          # jz src_finish
31 DB                   # xor ebx, ebx            ; ebx=0=stdin
E8 %read                # call read
89 D3                   # mov ebx, edx            ;  prepare to write
E8 %write               # call write
49                      # dec ecx   ; count--
EB !read_write_loop     # jmp read_write_loop

:src_finish
5F                      # pop edi
5E                      # pop esi
5A                      # pop edx
59                      # pop ecx
5B                      # pop ebx
58                      # pop eax
C3                      # ret



#------
:hex0_str
#h  e  x  0 \0
68 65 78 30 00

#------------------------------------------------------------
:hex0
53                      # push ebx
56                      # push esi
57                      # push edi

BE &hex0_str            # mov esi, hex0_str
E8 %console_puts        # call console_puts

# read "ex0 '
B1 04                   # mov cl, 4
:ex0_loop
E8 %read                # call read
FE C9                   # dec cl
75 !ex0_loop            # jnz ex0_loop

# clear arguments
31 C0                   # xor eax, eax
BA 00 00 D0 04          # mov edx, 0x04D00000
B9 00 08 00 00          # mov ecx, 0x00000800
:hex0_args_zeroloop
88 02                   # mov [edx], al
42                      # inc edx
49                      # dec ecx
75 !hex0_args_zeroloop  # jnz hex0_args_zeroloop

BA 00 00 D0 04          # mov edx, 0x04D00000
:get_filename1_loop
E8 %read                # call read
E8 %console_putc        # call console_putc
3C 20                   # cmp al, ' '
74 !got_filename1       # je got_filename1
88 02                   # mov [edx], al
42                      # inc edx
EB !get_filename1_loop  # jmp get_file_name1_loop

:got_filename1
BA 00 04 D0 04          # mov edx, 0x04D00400
:get_filename2_loop
E8 %read                # call read
E8 %console_putc        # call console_putc
3C 0A                   # cmp al, '\n'
74 !got_filename2       # je got_filename2
88 02                   # mov [edx], al
42                      # inc edx
EB !get_filename2_loop  # jmp get_file_name2_loop

:got_filename2
# open filename1 for read
BB 00 00 D0 04          # mov ebx, 0x04D00000
B8 05 00 00 00          # mov eax, 5  ; syscall_open
B9 00 00 00 00          # mov ecx, 0x00000000
CD 80                   # int 80

50                      # push eax  ; save read filenum

# open filename2 for write
BB 00 04 D0 04          # mov ebx, 0x04D00400
B8 05 00 00 00          # mov eax, 5  ; syscall_open
B9 41 02 00 00          # mov ecx, 0x00000241 O_TRUNC (0x200) | O_CREAT (0x40) | O_WRONLY (0x1)
BA 80 01 00 00          # mov edx, 0x00000180 S_IRUSR (0x100) | S_IWUSR (0x80)
CD 80                   # int 80
89 C2                   # mov edx, eax

59                      # pop ecx                 ; restore read filenum

# this flag is set after the first digit is seen
31 DB                   # xor ebx, ebx


#------
:hex0_read_loop
53                      # push ebx
89 CB                   # mov ebx, ecx
E8 %read                # call read
5B                      # pop ebx

84 E4                   # test ah, ah
75 !check_command       # jnz check_command
5F                      # pop edi
5E                      # pop esi
5B                      # pop ebx
C3                      # ret

:check_command
3C 23                   # cmp al, '#'

74 !skip_comment        # jz skip_comment

3C 3B                   # cmp ';'
74 !skip_comment        # jz skip_comment

3C 66                   # cmp al, 'f'
7F !hex0_read_loop      # jg hex0_read_loop

3C 61                   # cmp al, 'a'
7C !maybe_upper         # jl maybe_upper

# Handle a to f
2C 57                   # sub al, 'a'-10 == 87 = 0x57
EB !maybe_store         # jmp maybe_store

:maybe_upper
3C 46                   # cmp al, 'F'
7F !hex0_read_loop      # jg hex0_read_loop

3C 41                   # cmp al, 'A'
7C !maybe_digit         # jl maybe_digit

# Handle A to F
2C 37                   # sub al, 'A'-10 == 55 = x37
EB !maybe_store         # jmp maybe_store

:maybe_digit
3C 39                   # cmp al, '9'
7F !hex0_read_loop      # jg hex0_read_loop

3C 30                   # cmp al, '0'
7C !hex0_read_loop      # jl hex0_read_loop

# Handle 0 to 9
2C 30                   # sub al, '0' == x30
EB !maybe_store         # jmp maybe_store

:skip_comment
53                      # push ebx
89 CB                   # mov ebx, ecx
E8 %read                # call read
5B                      # pop ebx
3C 0A                   # cmp al, '\n'
75 !skip_comment        # jnz skip_comment
EB !hex0_read_loop      # jmp hex0_read_loop

# only store on second digit
:maybe_store
84 DB                   # test bl, bl
75 !second_digit        # jnz second_digit

# If on first digit, record and keep going
:first_digit
C0 E0 04                # shl al, 4
88 C7                   # mov bh, al
FE C3                   # inc bl
EB !hex0_read_loop      # jmp hex0_read_loop

# If on second digit, store and clear state
:second_digit
08 C7                   # or bh, al
88 F8                   # mov al, bh

53                      # push ebx
89 D3                   # mov ebx, edx
E8 %write               # call write
5B                      # pop ebx

31 DB                   # xor bx, bx
E9 %hex0_read_loop      # jmp hex0_read_loop


#------
:cmd_args
00 00 D0 04
00 04 D0 04

#------
:cmd_env
00 00 00 00

#------------------------------------------------------------
:handle_other_command
50                         # push eax
53                         # push ebx
51                         # push ecx
52                         # push edx
56                         # push esi

83 3D &enable_flush 00     # cmp [enable_flush], 0
74 !clear_args             # je clear_args
E8 %flush_disk             # call flush_disk

:clear_args
# clear arguments
BA 00 00 D0 04             # mov edx, 0x04D00000
88 02                      # mov [edx], al
42                         # inc edx
31 C0                      # xor eax, eax
B9 FF 07 00 00             # mov ecx, 0x000007FF
:other_args_zeroloop
88 02                      # mov [edx], al
42                         # inc edx
49                         # dec ecx
75 !other_args_zeroloop    # jnz other_args_zeroloop

# no more reading from disk - enable interrupts
40                         # inc eax
A3 &have_userspace         # mov [have_userspace], eax
FB                         # sti

BA 01 00 D0 04             # mov edx, 0x04D00001
:get_program_name
E8 %read                   # call read
3C 20                      # cmp al, ' '
74 !got_program_name       # je got_program_name
88 02                      # mov [edx], al
42                         # inc edx
EB !get_program_name       # jmp get_program_name

:got_program_name
BA 00 04 D0 04             # mov edx, 0x04D00400
:get_argument1_loop
E8 %read                   # call read
3C 0A                      # cmp al, '\n'
74 !got_argument1          # je got_argument1
88 02                      # mov [edx], al
42                         # inc edx
EB !get_argument1_loop     # jmp get_argument1_loop

:got_argument1
BE 00 00 D0 04             # mov esi, program
E8 %console_puts           # call console_puts

BE 00 04 D0 04             # mov esi, arg1
E8 %console_puts           # call console_puts

BB 00 00 D0 04             # mov ebx, program_name
B9 &cmd_args               # mov ecx, cmd_args
BA &cmd_env                # mov edx, cmd_env
E8 %handle_syscall_execve  # call handle_syscall_execve

5E                         # pop esi
5A                         # pop edx
59                         # pop ecx
5B                         # pop ebx
58                         # pop eax
C3                         # ret

#------
:enable_flush
00 00 00 00

#------------------------------------------------------------
:flush_disk
50                       # push eax
# copy memory file /dev/hda to the boot disk
BB &str_dev_hda          # mov ebx, str_dev_hda
E8 %find_file            # call find_file
83 F8 FF                 # cmp eax, -1
75 !ok_flush             # jne ok_flush

:error_exit
BE &str_error_no_writes  # mov esi, str_error_no_write
E8 %console_puts         # call console_puts

# one space to flush last line
B0 20                    # mov al, 20
E8 %console_putc         # call console_putc
58                       # pop eax
C3                       # ret

:ok_flush
# get file address to read
C1 E0 04                 # shl eax, 04
05 00 00 00 01           # add eax, 0x01000000
8B 70 04                 # mov esi, [eax+4]         ; file_address
8B 58 08                 # mov ebx, [eax+8]         ; bytes_to_write = file_length

# print length
89 D8                    # mov eax, ebx
B9 04 00 00 00           # mov ecx, 4
:shift_loop
C1 C8 18                 # ror eax, 24
E8 %console_put_hex      # call console_put_hex
49                       # dec ecx
75 !shift_loop           # jnz shift_loop
B0 0A                    # mov al, 0A
E8 %console_putc         # call console_putc

# set starting disk location to write
31 C9                    # xor ecx, ecx

:sector_loop
# copy 512 bytes from file to 16 bit buffer
51                       # push ecx                 ; save disk location
BF 00 A0 00 00           # mov edi, 0x000A000
B9 00 02 00 00           # mov ecx, 0x200
F3 A4                    # rep movsb
59                       # pop ecx

# now write from 16 bit buffer
56                       # push esi                 ; save our location in the file
BE 00 A0 00 00           # mov esi, 0x000A000
B8 01 00 00 00           # mov eax, 0x0001          ; num_sectors = 1
E8 %write_sectors        # call write_sectors
5E                       # pop esi

81 EB 00 02 00 00        # sub ebx, 0x200           ; bytes_to_write -= 512

7F !sector_loop          # jg sector_loop

B0 20                    # mov al, 20
E8 %console_putc         # call console_putc
58                       # pop eax
C3                       # ret


#------
:str_build_finished
#B  u  i  l  d     f  i  n  i  s  h  e  d  . \0
42 75 69 6C 64 20 66 69 6E 69 73 68 65 64 2E 00

#------
:str_error_no_writes
#E  R  R  O  R  :     n  o     h  d  a     w  r  i  t  e  s  ! \0
45 52 52 4F 52 3A 20 6E 6F 20 68 64 61 20 77 72 69 74 65 73 21 00

#------
:str_dev_hda
#/  d  e  v  /  h  d  a \0
2F 64 65 76 2F 68 64 61 00


#------------------------------------------------------------
:internalshell
B8 &kernel_entry               # mov eax, $kernel_entry
3D 00 7C 00 00                 # cmp eax, 0x00007C00
75 !stage2_stdin               # jne stage2_stdin

# Start reading stdin from logical sector 8
C7 05 00 00 00 01 08 00 00 00  # mov word [0x01000000], 0x00000008
EB !after_set_stdin            # jmp after_set_stdin

:stage2_stdin
# Start reading stdin from logical sector 168
C7 05 00 00 00 01 A8 00 00 00  # mov word [0x01000000], 0x000000A8

:after_set_stdin
# start at "end of sector" to trigger an initial sector read
66 C7 05 04 00 00 01 FF 01     # mov word [0x01000004], 0x01FF
66 C7 05 00 01 02 00 2F 00     # mov [0x00020100], 0x002F     ; proc[0].cwd = "/"
66 C7 05 00 11 02 00 2F 00     # mov [0x00021100], 0x002F     ; proc[1].cwd = "/"

# clear file descriptors for process 0
BF 00 02 02 00                 # mov edi, 0x00020200
B9 00 0E 00 00                 # mov ecx, 0x00000E00
31 C0                          # xor eax, eax
F3 AA                          # rep stosb

# clear file name table
BF 00 00 20 00                 # mov edi, 0x00200000
B9 00 00 E0 00                 # mov ecx, 0x00E00000
F3 AA                          # rep stosb

# read from stdin
31 DB                          # xor ebx, ebx

:process_command
E8 %read                       # call read
3C 00                          # cmp al, 0
74 !build_finished             # je build_finished

:check_src_command
3C 73                          # cmp al, 's'
75 !check_hex0_command         # jne check_hex0_command

:handle_src_command
E8 %src                        # call src
EB !process_command            # jmp process_command

:check_hex0_command
3C 68                          # cmp al, 'h'
75 !check_flush_command        # jne check_flush_command

:handle_hex0_command
E8 %hex0                       # call hex0
EB !process_command            # jmp process_command

:check_flush_command
3C 66                          # cmp al, 'f'
75 !call_handle_other_command  # jne call_handle_other_command

:handle_flush_command
E8 %read                       # call read    ; read the newline
FF 05 &enable_flush            # inc dword [enable_flush]
EB !process_command            # jmp process_command

:call_handle_other_command
E8 %handle_other_command       # call handle_other_command
EB !process_command            # jmp process_command

:build_finished
BE &str_build_finished         # mov esi, str_build_finished
E8 %console_puts               # call console_puts

E8 %flush_disk                 # call flush_disk

:shell_reboot
E9 %reboot                     # jmp reboot

# sector padding
00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
